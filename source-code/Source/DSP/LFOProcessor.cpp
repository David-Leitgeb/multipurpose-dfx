/*
  ==============================================================================

	LFOProcessor.cpp
	Created: 8 May 2024 10:34:24am
	Author:  Bc. David Leitgeb

  ==============================================================================
*/

#include "LFOProcessor.h"

LFOProcessor::LFOProcessor() : lfoBuffer(1, 256), lfoBlock(lfoBuffer), lfoFilter(juce::dsp::IIR::Coefficients<float>::makeLowPass(sampleRate, lfoFilterCutoffFreq))
{
	lfoBuffer.clear();
}

void LFOProcessor::prepare(juce::dsp::ProcessSpec& spec, int samplesPerBlock)
{
	sampleRate = spec.sampleRate;
	lfoDepth.reset(sampleRate, 0.02f);
	// Making sure the lfoBuffer parameters are adjusted depending on the audio settings.
	lfoBuffer.setSize(1, samplesPerBlock, true, true, false);
	lfoBlock = juce::dsp::AudioBlock<float>(lfoBuffer);
	// Calling the prepare method of the smoothing filter.
	lfoFilter.prepare(spec);
}

juce::dsp::AudioBlock<float>& LFOProcessor::generateSignal()
{
	float* data = lfoBlock.getChannelPointer(0);

	// Replacing the internal LFO phase with the one
	// calculated from the DAW playhead position.
	if (hostIsPlaying && retriggerLFO)
	{
		lfoPhase = hostLfoPhase -0.25f;
		retriggerLFO = false;
	}

	for (int sample = 0; sample < lfoBuffer.getNumSamples(); ++sample)
	{
		float f = 1;
		// Checking the LFO rate mode.
		switch (lfoRateMode)
		{
		case false:
			{
			f = lfoRateHz;
			}
			break;
		case true:
			{
				// Note length switch:
				switch (lfoRateSync)
				{
					case 1:
						{
						f = 1 / (4 * (60 / bpm) * 1);
						}
						break;
					case 2:
					{
						f = 1 / (4 * (60 / bpm) * 1 / 2);
					}
					break;
					case 3:
					{
						f = 1 / (4 * (60 / bpm) * 1 / 4);
					}
					break;
					case 4:
					{
						f = 1 / (4 * (60 / bpm) * 1 / 8);
					}
					break;
					case 5:
					{
						f = 1 / (4 * (60 / bpm) * 1 / 16);
					}
					break;
					case 6:
					{
						f = 1 / (4 * (60 / bpm) * 1 / 32);
					}
					break;
					default:
					{
					}
					break;
				}

			}
			break;
		default:
		{
		}
		break;
		}

		// Choosing which type of signal is generated.
		switch (lfoShape)
		{
			case 1: // Sine
			{
				data[sample] = (lfoDepth.getNextValue() / 100.0f) * std::sin(2.0f * juce::MathConstants<float>::pi * lfoPhase);
			}
			break;
			case 2: // Triangle
			{
				data[sample] = (lfoDepth.getNextValue() / 100.0f) * (2.0f * fmod(lfoPhase, 1.0) - 1.0f);
				data[sample] = 2 * abs(data[sample]) - 1;
			}
			break;
			case 3: // Square
			{
				data[sample] = (lfoDepth.getNextValue() / 100.0f) * (2.0f * fmod(lfoPhase, 1.0) - 1.0f);
				if (data[sample] <= 0)
					data[sample] = -1;
				if (data[sample] > 0)
					data[sample] = 1;
			}
			break;
			case 4: // Sawtooth
				{
					data[sample] = (lfoDepth.getNextValue() / 100.0f) * (2.0f * fmod(lfoPhase, 1.0) - 1.0f);
				}
			break;
			case 5: // Sample&Hold
			{
					// Calculating the amount of samples the LFO value should be held for.
					int holdTime = std::round(sampleRate / f);

					// If the desired hold interval has passed, new LFO value is generated.
					if((noiseIndex % holdTime) == 0)
					{
						noiseValue = 2.0f * randNumGenerator.nextFloat() - 1.0f;
						noiseIndex++;
					}
					else
					{
						noiseIndex++;
					}
				// Setting the output LFO value generated by S&H.
				data[sample] = (lfoDepth.getNextValue() / 100.0f) * noiseValue;
			}
			break;
			default:
				{
				}
				break;

		}

		// Phase update
		lfoPhase += (f / sampleRate);
		if (lfoPhase >= 1.0f)
		{
			lfoPhase -= 1.0f;
		}
	}

	// LFO signal is filtered with a lowpass filter.
	juce::dsp::ProcessContextReplacing<float> context(lfoBlock);
	lfoFilter.process(context);

	return lfoBlock;
}

void LFOProcessor::setParameters(int newLfoShape, int newLfoRateSync, float newLfoRateHz, int newLfoDepth, bool newLfoRateMode, float newBpm, bool newHostIsPlaying, float newHostLfoPhase, bool newRetriggerLfo)
{
	lfoShape = newLfoShape;
	lfoRateSync = newLfoRateSync;
	lfoRateHz = newLfoRateHz;
	lfoDepth.setTargetValue(newLfoDepth);
	lfoRateMode = newLfoRateMode;
	// BPM and DAW playhead synchronization.
	bpm = newBpm;
	hostIsPlaying = newHostIsPlaying;
	hostLfoPhase = newHostLfoPhase;
	retriggerLFO = newRetriggerLfo;
}
